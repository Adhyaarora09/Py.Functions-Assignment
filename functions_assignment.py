# -*- coding: utf-8 -*-
"""Functions Assignment

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1vypWpPTlYKR15dhukpF3OmjQzY5hHHXF

Theory Answer:-


1Que:- What is the difference between a function and a method in Python?

Ans:- Here, key differences between Method and Function in Python are explained. Java is also an OOP language, but there is no concept of Function in it. But Python has both concept of Method and Function.

Python Method

Method is called by its name, but it is associated to an object (dependent).

A method definition always includes 'self' as its first parameter.

A method is implicitly passed to the object on which it is invoked.

It may or may not return any data.

A method can operate on the data (instance variables) that is contained by the corresponding class.


Basic Method Structure in Python :

Example:

# Basic Python method
class class_name
    def method_name () :
        ......
        # method body
        ......


Python 3 User-Defined Method :

# Python 3  User-Defined  Method
class ABC :
    def method_abc (self):
        print("I am in method_abc of ABC class. ")

class_ref = ABC() # object of ABC class
class_ref.method_abc()

Output:

 I am in method_abc of ABC class.

 Functions

Function is block of code that is also called by its name. (independent)

The function can have different parameters or may not have any at all. If any data (parameters) are passed, they are passed explicitly.

It may or may not return any data.

Function does not deal with Class and its instance concept.


Basic Function Structure in Python :

Example:

  def function_name ( arg1, arg2, ...) :
    ......
    # function body
    ......

def Subtract (a, b):
    return (a-b)

print( Subtract(10, 12) ) # prints -2

print( Subtract(15, 6) ) # prints 9

Output:

-2

9

2Que:- . Explain the concept of function arguments and parameters in Python?

Ans:-  Parameters: are variables defined in a function declaration. This act as placeholders for the values (arguments) that will be passed to the function.

Arguments: are the actual values that you pass to the function when you call it. These values replace the parameters defined in the function.

Although these terms are often used interchangeably, they have distinct roles within a function. This article focuses to clarify them and help us to use Parameters and Arguments effectively.

Parameters:

A parameter is the variable defined within the parentheses when we declare a function.

Example:-

# Here a,b are the parameters

def sum(a,b):

   print(a+b)
  
sum(1,2)

Output:

 3

Arguments:

An argument is a value that is passed to a function when it is called. It might be a variable, value or object passed to a function or method as input.

Example:

def sum(a,b):

  print(a+b)
  
# Here the values 1,2 are arguments

sum(1,2)

Output:

3

3Que:- What are the different ways to define and call a function in Python?

Ans:- In Python, defining and calling functions is simple and may greatly improve the readability and reusability of our code. In this article, we will explore How we can define and call a function.

# Defining a function

def fun():

    print("Welcome to GFG")
    
# calling a function  

fun()

Example:

# Defining a function

def fun():

    print("Welcome to GFG")
    
# calling a function   

fun()

Output:

Welcome to GFG


4Que:-  What is the purpose of the `return` statement in a Python function?

Ans:- A return statement is used to end the execution of the function call and it "returns" the value of the expression following the return keyword to the caller. The statements after the return statements are not executed. If the return statement is without any expression, then the special value None is returned. A return statement is overall used to invoke a function so that the passed statements can be executed.

Example:

A return statement is used to end the execution of the function call and it "returns" the value of the expression following the return keyword to the caller. The statements after the return statements are not executed. If the return statement is without any expression, then the special value None is returned. A return statement is overall used to invoke a function so that the passed statements can be executed.

Example:

def add(a, b):

    # returning sum of a and b
    return a + b

def is_true(a):

    # returning boolean of a
    return bool(a)

# calling function
res = add(2, 3)
print(res)

res = is_true(2<5)
print(res)


Output:

5
True


5Que:  What are iterators in Python and how do they differ from iterables?

Ans:- Iterable is an object, that one can iterate over. It generates an Iterator when passed to iter() method. An iterator is an object, which is used to iterate over an iterable object using the __next__() method. Iterators have the __next__() method, which returns the next item of the object.

Note: Every iterator is also an iterable, but not every iterable is an iterator in Python.

For example, a list is iterable but a list is not an iterator. An iterator can be created from an iterable by using the function iter(). To make this possible, the class of an object needs either a method __iter__, which returns an iterator, or a __getitem__ method with sequential indexes starting with 0.

Example 1:

We know that str is iterable but it is not an iterator. where if we run this in for loop to print string then it is possible because when for loop executes it converts into an iterator to execute the code.

# code
next("GFG")

Traceback (most recent call last):
  File "/home/1c9622166e9c268c0d67cd9ba2177142.py", line 2, in <module>
    next("GFG")

TypeError: 'str' object is not an iterator

Here iter( ) is converting s which is a string (iterable) into an iterator and prints G for the first time we can call multiple times to iterate over strings.

When a for loop is executed, for statement calls iter() on the object, which it is supposed to loop over.

If this call is successful, the iter call will return an iterator object that defines the method __next__(), which accesses elements of the object one at a time.


# code
s="GFG"
s=iter(s)
print(s)
print(next(s))
print(next(s))
print(next(s))

Output:

<str_iterator object at 0x7f822a9c3210>

G
F
G

The __next__() method will raise a StopIteration exception if there are no further elements available.

The for loop will terminate as soon as it catches a StopIteration exception.

Let's call the __next__() method using the next() built-in function.


6Que:-  Explain the concept of generators in Python and how they are defined.

Ans:- Python generator functions are a powerful tool for creating iterators. In this article, we will discuss how the generator function works in Python.

Generator Function in Python:

A generator function is a special type of function that returns an iterator object. Instead of using return to send back a single value, generator functions use yield to produce a series of results over time. This allows the function to generate values and pause its execution after each yield, maintaining its state between iterations.

Basic Code Example:

def fun(max):
    cnt = 1
    while cnt <= max:
        yield cnt
        cnt += 1

ctr = fun(5)
for n in ctr:
    print(n)

Output:

1

2

3

4

5

Yield vs Return:

yield is used in generator functions to provide a sequence of values over time. When yield is executed, it pauses the function, returns the current value and retains the state of the function. This allows the function to continue from the same point when called again, making it ideal for generating large or complex sequences efficiently.

return, on the other hand, is used to exit a function and return a final value. Once return is executed, the function is terminated immediately, and no state is retained. This is suitable for cases where a single result is needed from a function.

Example with return:

def fun():

    return 1 + 2 + 3

res = fun()

print(res)

Output:

6

Python Generator Expression:

Generator expressions are a concise way to create generators. They are similar to list comprehensions but use parentheses instead of square brackets and are more memory efficient.

The generator expression in Python has the following Syntax:

(expression for item in iterable)

Example:

In this example, we will create a generator object that will print the multiples of 5 between the range of 0 to 5 which are also divisible by 2.


sq = (x*x for x in range(1, 6))

for i in sq:

    print(i)


7Que:  What are the advantages of using generators over regular functions?

Ans: Advantages of Generators Over Regular Functions:

There are several advantages to using generators over regular loops.

 Here are a few of the most important ones:

Memory Efficiency: One of the biggest advantages of generators is that they are memory efficient. Since a generator yields its values one by one, it does not need to store all of the values in memory at once. This can be especially useful when working with large data sets, as it reduces the risk of running out of memory.

Readability: Generators can make your code easier to read and understand. By breaking up the iteration process into smaller chunks, you can write code that is more concise and easier to follow.
Speed: Generators can also be faster than regular loops, especially when working with large data sets. This is because they avoid the overhead of creating a list or other data structure to store the results.

Here’s an example that demonstrates the memory efficiency and readability benefits of generators:

def first_million_numbers():

    for i in range(1000000):

        yield i

gen = first_million_numbers()

print(sum(gen))

In this example, the generator first_million_numbers generates the first million numbers and yields them one by one. The sum function consumes the generator and calculates the sum of all the numbers. Since the generator yields its values one by one, it does not need to store all of the values in memory at once.


8Que:-  What is a lambda function in Python and when is it typically used?

Ans:- Python Lambda Functions are anonymous functions means that the function is without a name. As we already know the def keyword is used to define a normal function in Python. Similarly, the lambda keyword is used to define an anonymous function in Python.

Example:

In the example, we defined a lambda function(upper) to convert a string to its upper case using upper().

s1 = 'GeeksforGeeks'

s2 = lambda func: func.upper()

print(s2(s1))


Output:

GEEKSFORGEEKS

This code defines a lambda function named s2 that takes a string as its argument and converts it to uppercase using the upper() method. It then applies this lambda function to the string 'GeeksforGeeks' and prints the result.

Let's explore Lambda Function in detail:

Python Lambda Function Syntax:

Syntax: lambda arguments : expression

lambda: The keyword to define the function.
arguments: A comma-separated list of input parameters (like in a regular function).

expression: A single expression that is evaluated and returned.
Let's see some of the practical uses of the Python lambda function.

lambda with Condition Checking:
A lambda function can include conditions using if statements.

Example:

# Example: Check if a number is positive, negative, or zero

n = lambda x: "Positive" if x > 0 else "Negative" if x < 0 else "Zero"

print(n(5))

print(n(-3))  

print(n(0))

Output:

Positive

Negative

Zero

Explanation:

The lambda function takes x as input.

It uses nested if-else statements to return "Positive," "Negative," or "Zero.

9Que: Explain the purpose and usage of the `map()` function in Python.

Ans: The map() function is used to apply a given function to every item of an iterable, such as a list or tuple, and returns a map object (which is an iterator).

Let's start with a simple example of using map() to convert a list of strings into a list of integers.

s = ['1', '2', '3', '4']

res = map(int, s)

print(list(res))

Output:

[1, 2, 3, 4]

Explanation: Here, we used the built-in int function to convert each string in the list s into an integer. The map() function takes care of applying int() to every element.

10Que: What is the difference between `map()`, `reduce()`, and `filter()` functions in Python?

Ans: Map Functions:

 Definition: The map function applies a given function to all items in an input iterable (like a list) and returns an iterator with the results.

Key Points:

Transformation: Used to transform each item in an iterable by applying the specified function.
Syntax:

map(function, iterable)


 Example:

 number = [1,2,3,4]

Squared =  map(lambda x:x*x , numbers)

print(list(Squared))

Output:

1 4 9 16

The filter() Function:

Similar to map(), filter() takes a function object and an iterable and creates a new list.

As the name suggests, filter() forms a new list that contains only elements that satisfy a certain condition, i.e. the function we passed returns True.

The syntax is:

filter(function, iterable(s))

Using the previous example, we can see that the new list will only contain elements for which the starts_with_A() function returns True:

# Without using lambdas

def starts_with_A(s):

    return s[0] == "A"

fruit = ["Apple", "Banana", "Pear", "Apricot", "Orange"]

filter_object = filter(starts_with_A, fruit)

print(list(filter_object))

Running this code will result in a shorter list:

['Apple', 'Apricot']

Or, rewritten using a lambda:

fruit = ["Apple", "Banana", "Pear", "Apricot", "Orange"]

filter_object = filter(lambda s: s[0] == "A", fruit)

print(list(filter_object))

Printing gives us the same output:

['Apple', 'Apricot']

The reduce() Function:

reduce() works differently than map() and filter(). It does not return a new list based on the function and iterable we've passed. Instead, it returns a single value.

Also, in Python 3 reduce() isn't a built-in function anymore, and it can be found in the functools module.

The syntax is:

reduce(function, sequence[, initial])

reduce() works by calling the function we passed for the first two items in the sequence. The result returned by the function is used in another call to function alongside with the next (third in this case), element.

This process repeats until we've gone through all the elements in the sequence.

The optional argument initial is used, when present, at the beginning of this "loop" with the first element in the first call to function. In a way, the initial element is the 0th element, before the first one, when provided.

reduce() is a bit harder to understand than map() and filter(), so let's look at a step by step example:

We start with a list [2, 4, 7, 3] and pass the add(x, y) function to reduce() alongside this list, without an initial value

reduce() calls add(2, 4), and add() returns 6

reduce() calls add(6, 7) (result of the previous call to add() and the next element in the list as parameters), and add() returns 13

reduce() calls add(13, 3), and add() returns 16

Since no more elements are left in the sequence, reduce() returns 16

from functools import reduce

def add(x, y):

    return x + y

list = [2, 4, 7, 3]

print(reduce(add, list))

Running this code would yield:

16

Again, this could be written using lambdas:

from functools import reduce

list = [2, 4, 7, 3]

print(reduce(lambda x, y: x + y, list))

print("With an initial value: " + str(reduce(lambda x, y: x + y, list, 10)))

And the code would result in:

16

With an initial value: 26


11Que:  Using pen & Paper write the internal mechanism for sum operation using  reduce function on this given
list:[47,11,42,13];
"""

from functools import reduce

# Function to add two numbers
def add(x, y):
    return x + y

a = [47,11,42,13]
res = reduce(add, a)

print(res)

"""     Pratical Answer:

1Que: Write a Python function that takes a list of numbers as input and returns the sum of all even numbers in
the list.
"""

num = int(input('Enter a number: '))
sum = 0
i = 0
while i <= num:
    if i % 2 == 0:
        print(i)
        sum+=i
    i+=1
print(f"Sum of all the even numbers is {sum}")

"""2Que: Create a Python function that accepts a string and returns the reverse of that string."""

def reverse_string(input_string):
    return ''.join(reversed(input_string))

string = "Hello, World!"
reversed_string = reverse_string(string)
print(reversed_string)

"""3Que: Implement a Python function that takes a list of integers and returns a new list containing the squares of
each number.
"""

list_nums= [1, 2, 3, 4, 5]

for i, v in enumerate(list_nums):
   list_nums[i] = v**2

print(list_nums)

"""4Que: Write a Python function that checks if a given number is prime or not from 1 to 200."""

number = int(input("Enter any number: "))

# prime number is always greater than 1
if number > 1:
    for i in range(2, number):
        if (number % i) == 0:
            print(number, "is not a prime number")
            break
    else:
        print(number, "is a prime number")

# if the entered number is less than or equal to 1
# then it is not prime number
else:
    print(number, "is not a prime number")

"""5Que:  Create an iterator class in Python that generates the Fibonacci sequence up to a specified number of
terms.
"""

#defining function to return list of fibonacci elements
def fibonacci(n):

    l = [0,1]
    for i in range(2,n):
        l.append(l[-1]+l[-2])
    return l

#Main function
if __name__ == "__main__":
   #defining the total number of elements
    n = 10

    #calling of function
    fibo = fibonacci(n)

    #displaying the function
    print("Fibonacci Series: ",*fibo)

"""6Que: Write a generator function in Python that yields the powers of 2 up to a given exponent."""

def power_generator(base, exponent):
    result = 1
    for i in range(exponent + 1):
        yield result
        result *= base

# Accept input from the user
base = int(input("Input the base number: "))
exponent = int(input("Input the exponent: "))

# Create the generator object
power_gen = power_generator(base, exponent)

# Generate and print the powers
print(f"Powers of {base} up to exponent {exponent}:")
for power in power_gen:
    print(power)

"""7Que:  Implement a generator function that reads a file line by line and yields each line as a string."""

def read_file_lines(filepath):
    """
    Reads a file line by line and yields each line.

    Args:
        filepath (str): The path to the file.

    Yields:
        str: Each line of the file.
    """
    with open(filepath, 'r') as file:
        for line in file:
            yield line
filepath = 'my_file.txt'
with open(filepath, 'w') as f:
    f.write("This is the first line.\n")
    f.write("This is the second line.\n")
    f.write("This is the third line.\n")

for line in read_file_lines(filepath):
    print(line, end="")

"""8Que: Use a lambda function in Python to sort a list of tuples based on the second element of each tuple."""

def sort_tuples_by_second_element(list_of_tuples):
  """
  Sorts a list of tuples based on the second element of each tuple.

  Args:
    list_of_tuples: A list of tuples.

  Returns:
    A new list of tuples sorted by the second element.
  """
  return sorted(list_of_tuples, key=lambda x: x[1])

# Example usage:
my_list = [(1, 'z'), (2, 'a'), (3, 'b')]
sorted_list = sort_tuples_by_second_element(my_list)
print(sorted_list)
# Expected output: [(2, 'a'), (3, 'b'), (1, 'z')]

"""9Que: Write a Python program that uses `map()` to convert a list of temperatures from Celsius to Fahrenheit."""

def celsius_to_fahrenheit(celsius):
  """Converts Celsius to Fahrenheit."""
  return (celsius * 9/5) + 32

# Example list of Celsius temperatures
celsius_temperatures = [0, 10, 20, 30, 40]

# Use map to apply the conversion function to each element
fahrenheit_temperatures = list(map(celsius_to_fahrenheit, celsius_temperatures))

# Print the results
print("Celsius temperatures:", celsius_temperatures)
print("Fahrenheit temperatures:", fahrenheit_temperatures)

"""10Que:  Create a Python program that uses `filter()` to remove all the vowels from a given string."""

string = "Education"

vowels = ['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U']
result = ""

for i in range(len(string)):
    if string[i] not in vowels:
        result = result + string[i]

print("\nAfter removing Vowels: ", result)

"""11Que: Write a Python program, which returns a list with 2-tuples. Each tuple consists of the order number and the
product of the price per item and the quantity. The product should be increased by 10,- € if the value of the
order is smaller than 100,00 €.

Write a Python program using lambda and map.


Ans:
 from functools import reduce

'''

1.Imagine an accounting routine used in a book shop. It works on a list with sublists, which look like this:

Order Number	Book Title and Author	Quantity	Price per Item
34587	Learning Python, Mark Lutz	4	40.95
98762	Programming Python, Mark Lutz	5	56.80
77226	Head First Python, Paul Barry	3	32.95
88112	Einführung in Python3, Bernd Klein	3	24.99


Write a Python program, which returns a list with 2-tuples. Each tuple consists of a the order number and the product of the price per items and the quantity. The product should be increased by 10,- € if the value of the order is less than 100,00 €.
Write a Python program using lambda and map.


2.The same bookshop, but this time we work on a different list. The sublists of our lists look like this:
[ordernumber, (article number, quantity, price per unit), ... (article number, quantity, price per unit) ]
Write a program which returns a list of two tuples with (order number, total amount of order).

'''

#Solution-1

orders = [ ["34587", "Learning Python, Mark Lutz", 4, 40.95],["98762", "Programming Python, Mark Lutz", 5, 56.80],["77226", "Head First Python, Paul Barry", 3,32.95],["88112", "Einführung in Python3, Bernd Klein", 	3, 24.99]]

invoice_totals = list(map(lambda x: x if x[1] >= min_order else (x[0], x[1] + 10),map(lambda x: (x[0],x[2] * x[3]), orders)))

#Note- To understand the working of above lambda function break the function till innermost map function. Break and understand in below fashion
'''
output1 = map(lambda x: (x[0],x[2] * x[3]), orders) #Innermost lambda function execution

output2 = map(lambda x: x if x[1] >= min_order else (x[0], x[1] + 10),map(lambda x: (x[0],x[2] * x[3]), orders))

final = list(map(lambda x: x if x[1] >= min_order else (x[0], x[1] + 10),map(lambda x: (x[0],x[2] * x[3]), orders)))
'''

#Solution-2

from functools import reduce

orders = [ [1, ("5464", 4, 9.99), ("8274",18,12.99), ("9744", 9, 44.95)],[2, ("5464", 9, 9.99), ("9744", 9, 44.95)],[3, ("5464", 9, 9.99), ("88112", 11, 24.99)],[4, ("8732", 7, 11.99), ("7733",11,18.99), ("88112", 5, 39.95)] ]

invoice = list(map(lambda k: k if k[1]>=100 else (k[0],k[1]+10),map(lambda x:(x[0],reduce(lambda a,b:a+b,list(map(lambda y:y[1]*y[2] ,x[1:])))),orders)))

#Breaking

'''
output1=map(lambda y:y[1]*y[2] ,x[1:])
output2=list(map(lambda y:y[1]*y[2] ,x[1:]))
output3=reduce(lambda a,b:a+b,list(map(lambda y:y[1]*y[2] ,x[1:])))
output4=map(lambda x:(x[0],reduce(lambda a,b:a+b,list(map(lambda y:y[1]*y[2] ,x[1:]))))
output5=map(lambda k: k if k[1]>=100 else (k[0],k[1]+10),map(lambda x:(x[0],reduce(lambda a,b:a+b,list(map(lambda y:y[1]*y[2] ,x[1:])))),orders))
output6=list(map(lambda k: k if k[1]>=100 else (k[0],k[1]+10),map(lambda x:(x[0],reduce(lambda a,b:a+b,list(map(lambda y:y[1]*y[2] ,x[1:])))),orders)))
'''


"""